const should = require('should');

const zapier = require('zapier-platform-core');

const App = require('../../index');
const Contact = require('../../entities/contact');
const appTester = zapier.createAppTester(App);

describe('creates', () => {

  describe('create contact', () => {
    it('should create a new contact', (done) => {
      zapier.tools.env.inject();
      const bundle = {
        inputData: {
          firstname: 'John',
          lastname: 'Doe',
          email: 'john@doe.email',
          points: 7,
          tags: 'zapier, api, -deleted'
        },
          authData: {
              access_token: process.env.ACCESS_TOKEN,
              baseUrl: process.env.BASE_URL,
          },
      };

      appTester(App.creates.contact.operation.perform, bundle)
        .then((result) => {
          result.firstname.should.equal('John');
          result.lastname.should.equal('Doe');
          result.email.should.equal('john@doe.email');
          result.points.should.equal(7);
          result.tags.should.be.oneOf(['zapier,api', 'api,zapier']);
          done();
        })
        .catch(done);
    }).timeout(15000);

    it('should update the previously created contact', (done) => {
      zapier.tools.env.inject();
      const bundle = {
        inputData: {
          email: 'john@doe.email',
          // The empty values should not overwrite previously set value
          firstname: null,
          lastname: '',
        },
          authData: {
              access_token: process.env.ACCESS_TOKEN,
              baseUrl: process.env.BASE_URL,
          },
      };

      appTester(App.creates.contact.operation.perform, bundle)
        .then((result) => {
          // The contact created by previous test should still have the data
          result.firstname.should.equal('John');
          result.lastname.should.equal('Doe');
          result.email.should.equal('john@doe.email');
          result.points.should.equal(7);
          result.tags.should.be.oneOf(['zapier,api', 'api,zapier']);
          done();
        })
        .catch(done);
    }).timeout(15000);

    it('should clean contact from fake request', (done) => {
      const request = require('../../fixtures/requests/contact.js');
      const contact = new Contact(null, null);
      const cleanContact = contact.cleanContact(request);

      cleanContact.should.eql(require('../../fixtures/samples/contact.js'));
      done();
    });

    it('should not create a new contact when no fields mapped', (done) => {
      zapier.tools.env.inject();
      const bundle = {
        inputData: {}
      };

      appTester(App.creates.contact.operation.perform, bundle)
        .then(() => {
          done('Should not get here');
        })
        .catch((error) => {
          error.message.should.containEql('No fields were mapped. Please fill in a value to some field(s).');
          done();
        });
    });

    it('input fields should not contain autogenerated data', (done) => {
      zapier.tools.env.inject();
      const bundle = {
          authData: {
              access_token: process.env.ACCESS_TOKEN,
              baseUrl: process.env.BASE_URL,
          },
      };

      appTester(App.creates.contact.operation.inputFields, bundle)
        .then((fields) => {
          fields.should.not.containEql({key: 'tags', label: 'Tags', helpText: 'Comma separated tags. Use - before the tag if you want to remove it'});
          fields.should.containEql({key: 'addTags', type: 'string', label: 'Add Tags', dynamic: 'tags.id.tag', list: true, helpText: 'Select the tags you want to add to the contact'});
          fields.should.containEql({key: 'removeTags', type: 'string', label: 'Remove Tags', dynamic: 'tags.id.tag', list: true, helpText: 'Select the tags you want to remove from the contact. Wroks only for updates of existing contacts.'});
          fields.should.containEql({key: 'email', label: 'Email', helpText: 'If a contact exists with this email address, then it will be updated. Email address is an identifier field by default.'});
          done();
        })
        .catch(done);
    }).timeout(15000);
  });
});
